# File produced by Kranc


shares: ADMBase


EXTENDS CCTK_KEYWORD evolution_method "evolution_method"
{
  "CL_BSSN" :: ""
} 


EXTENDS CCTK_KEYWORD lapse_evolution_method "lapse_evolution_method"
{
  "CL_BSSN" :: ""
} 


EXTENDS CCTK_KEYWORD shift_evolution_method "shift_evolution_method"
{
  "CL_BSSN" :: ""
} 


EXTENDS CCTK_KEYWORD dtlapse_evolution_method "dtlapse_evolution_method"
{
  "CL_BSSN" :: ""
} 


EXTENDS CCTK_KEYWORD dtshift_evolution_method "dtshift_evolution_method"
{
  "CL_BSSN" :: ""
} 



shares: GenericFD

USES CCTK_INT assume_stress_energy_state
USES CCTK_INT assume_use_jacobian
USES CCTK_STRING jacobian_group
USES CCTK_STRING jacobian_determinant_group
USES CCTK_STRING jacobian_inverse_group
USES CCTK_STRING jacobian_derivative_group
USES CCTK_INT jacobian_identity_map


shares: MethodOfLines

USES CCTK_INT MoL_Num_Evolved_Vars
USES CCTK_INT MoL_Num_ArrayEvolved_Vars

restricted:
CCTK_INT verbose "verbose" STEERABLE=ALWAYS
{
  *:* :: ""
} 0

restricted:
CCTK_INT other_timelevels "Number of active timelevels for non-evolved grid functions" STEERABLE=RECOVER
{
  0:3 :: ""
} 1

restricted:
CCTK_REAL harmonicF "d/dt alpha = - f alpha^n K   (harmonic=1, 1+log=2)"
{
  *:* :: ""
} 1

restricted:
CCTK_REAL DAlphaDriver "DAlphaDriver"
{
  *:* :: ""
} 0

restricted:
CCTK_REAL ShiftGammaCoeff "ShiftGammaCoeff"
{
  *:* :: ""
} 0

restricted:
CCTK_REAL BetaDriver "BetaDriver"
{
  *:* :: ""
} 0

restricted:
CCTK_REAL DBetaDriver "DBetaDriver"
{
  *:* :: ""
} 0

restricted:
CCTK_REAL DphiDriver "DphiDriver"
{
  *:* :: ""
} 0

restricted:
CCTK_REAL DgtDriver "DgtDriver"
{
  *:* :: ""
} 0

restricted:
CCTK_REAL sigma "sigma"
{
  *:* :: ""
} 1

restricted:
CCTK_REAL MinimumLapse "Minimum value of the lapse function"
{
  *:* :: ""
} -1

restricted:
CCTK_REAL SpatialBetaDriverRadius "Radius at which the BetaDriver starts to be reduced"
{
  (0:* :: "Positive"
} 1000000000000

restricted:
CCTK_INT harmonicN "d/dt alpha = - f alpha^n K  (harmonic=2, 1+log=1)"
{
  *:* :: ""
} 2

restricted:
CCTK_INT ShiftAlphaPower "ShiftAlphaPower"
{
  *:* :: ""
} 0

restricted:
CCTK_INT fdOrder "fdOrder"
{
  2 :: ""
  4 :: ""
  6 :: ""
  8 :: ""
} 4

restricted:
CCTK_INT harmonicShift "Whether to use the harmonic shift"
{
  0 :: "Gamma driver shift"
  1 :: "Harmonic shift"
} 0

restricted:
CCTK_INT tile_size "Loop tile size"
{
  *:* :: ""
} -1

private:
CCTK_KEYWORD my_initial_data "my_initial_data"
{
  "ADMBase" :: ""
  "Minkowski" :: ""
} "ADMBase"

restricted:
CCTK_KEYWORD my_initial_boundary_condition "my_initial_boundary_condition"
{
  "none" :: ""
} "none"

restricted:
CCTK_KEYWORD my_rhs_boundary_condition "my_rhs_boundary_condition"
{
  "none" :: ""
  "static" :: ""
} "none"

private:
CCTK_KEYWORD my_boundary_condition "my_boundary_condition"
{
  "none" :: ""
  "Minkowski" :: ""
} "none"

restricted:
CCTK_KEYWORD calculate_ADMBase_variables_at "calculate_ADMBase_variables_at"
{
  "MoL_PostStep" :: ""
  "CCTK_EVOL" :: ""
  "CCTK_ANALYSIS" :: ""
} "MoL_PostStep"

restricted:
CCTK_KEYWORD UseSpatialBetaDriver "UseSpatialBetaDriver"
{
  "no" :: ""
  "yes" :: ""
} "no"

restricted:
CCTK_INT CL_BSSN_MaxNumEvolvedVars "Number of evolved variables used by this thorn" ACCUMULATOR-BASE=MethodofLines::MoL_Num_Evolved_Vars STEERABLE=RECOVER
{
  57:57 :: "Number of evolved variables used by this thorn"
} 57

restricted:
CCTK_INT CL_BSSN_MaxNumArrayEvolvedVars "Number of Array evolved variables used by this thorn" ACCUMULATOR-BASE=MethodofLines::MoL_Num_ArrayEvolved_Vars STEERABLE=RECOVER
{
  0:0 :: "Number of Array evolved variables used by this thorn"
} 0

restricted:
CCTK_INT timelevels "Number of active timelevels" STEERABLE=RECOVER
{
  0:3 :: ""
} 3

restricted:
CCTK_INT rhs_timelevels "Number of active RHS timelevels" STEERABLE=RECOVER
{
  0:3 :: ""
} 1

restricted:
CCTK_INT CL_BSSN_Minkowski_calc_every "CL_BSSN_Minkowski_calc_every" STEERABLE=ALWAYS
{
  *:* :: ""
} 1

restricted:
CCTK_INT CL_BSSN_convertFromADMBase_calc_every "CL_BSSN_convertFromADMBase_calc_every" STEERABLE=ALWAYS
{
  *:* :: ""
} 1

restricted:
CCTK_INT CL_BSSN_convertFromADMBaseGamma_calc_every "CL_BSSN_convertFromADMBaseGamma_calc_every" STEERABLE=ALWAYS
{
  *:* :: ""
} 1

restricted:
CCTK_INT CL_BSSN_RHS1_calc_every "CL_BSSN_RHS1_calc_every" STEERABLE=ALWAYS
{
  *:* :: ""
} 1

restricted:
CCTK_INT CL_BSSN_RHS2_calc_every "CL_BSSN_RHS2_calc_every" STEERABLE=ALWAYS
{
  *:* :: ""
} 1

restricted:
CCTK_INT CL_BSSN_RHS3_calc_every "CL_BSSN_RHS3_calc_every" STEERABLE=ALWAYS
{
  *:* :: ""
} 1

restricted:
CCTK_INT CL_BSSN_RHSStaticBoundary_calc_every "CL_BSSN_RHSStaticBoundary_calc_every" STEERABLE=ALWAYS
{
  *:* :: ""
} 1

restricted:
CCTK_INT CL_BSSN_enforce_calc_every "CL_BSSN_enforce_calc_every" STEERABLE=ALWAYS
{
  *:* :: ""
} 1

restricted:
CCTK_INT CL_BSSN_boundary_calc_every "CL_BSSN_boundary_calc_every" STEERABLE=ALWAYS
{
  *:* :: ""
} 1

restricted:
CCTK_INT CL_BSSN_convertToADMBase_calc_every "CL_BSSN_convertToADMBase_calc_every" STEERABLE=ALWAYS
{
  *:* :: ""
} 1

restricted:
CCTK_INT CL_BSSN_convertToADMBaseDtLapseShift_calc_every "CL_BSSN_convertToADMBaseDtLapseShift_calc_every" STEERABLE=ALWAYS
{
  *:* :: ""
} 1

restricted:
CCTK_INT CL_BSSN_convertToADMBaseDtLapseShiftBoundary_calc_every "CL_BSSN_convertToADMBaseDtLapseShiftBoundary_calc_every" STEERABLE=ALWAYS
{
  *:* :: ""
} 1

restricted:
CCTK_INT CL_BSSN_constraints_calc_every "CL_BSSN_constraints_calc_every" STEERABLE=ALWAYS
{
  *:* :: ""
} 1

restricted:
CCTK_INT CL_BSSN_constraints_boundary_calc_every "CL_BSSN_constraints_boundary_calc_every" STEERABLE=ALWAYS
{
  *:* :: ""
} 1

restricted:
CCTK_INT CL_BSSN_Minkowski_calc_offset "CL_BSSN_Minkowski_calc_offset" STEERABLE=ALWAYS
{
  *:* :: ""
} 0

restricted:
CCTK_INT CL_BSSN_convertFromADMBase_calc_offset "CL_BSSN_convertFromADMBase_calc_offset" STEERABLE=ALWAYS
{
  *:* :: ""
} 0

restricted:
CCTK_INT CL_BSSN_convertFromADMBaseGamma_calc_offset "CL_BSSN_convertFromADMBaseGamma_calc_offset" STEERABLE=ALWAYS
{
  *:* :: ""
} 0

restricted:
CCTK_INT CL_BSSN_RHS1_calc_offset "CL_BSSN_RHS1_calc_offset" STEERABLE=ALWAYS
{
  *:* :: ""
} 0

restricted:
CCTK_INT CL_BSSN_RHS2_calc_offset "CL_BSSN_RHS2_calc_offset" STEERABLE=ALWAYS
{
  *:* :: ""
} 0

restricted:
CCTK_INT CL_BSSN_RHS3_calc_offset "CL_BSSN_RHS3_calc_offset" STEERABLE=ALWAYS
{
  *:* :: ""
} 0

restricted:
CCTK_INT CL_BSSN_RHSStaticBoundary_calc_offset "CL_BSSN_RHSStaticBoundary_calc_offset" STEERABLE=ALWAYS
{
  *:* :: ""
} 0

restricted:
CCTK_INT CL_BSSN_enforce_calc_offset "CL_BSSN_enforce_calc_offset" STEERABLE=ALWAYS
{
  *:* :: ""
} 0

restricted:
CCTK_INT CL_BSSN_boundary_calc_offset "CL_BSSN_boundary_calc_offset" STEERABLE=ALWAYS
{
  *:* :: ""
} 0

restricted:
CCTK_INT CL_BSSN_convertToADMBase_calc_offset "CL_BSSN_convertToADMBase_calc_offset" STEERABLE=ALWAYS
{
  *:* :: ""
} 0

restricted:
CCTK_INT CL_BSSN_convertToADMBaseDtLapseShift_calc_offset "CL_BSSN_convertToADMBaseDtLapseShift_calc_offset" STEERABLE=ALWAYS
{
  *:* :: ""
} 0

restricted:
CCTK_INT CL_BSSN_convertToADMBaseDtLapseShiftBoundary_calc_offset "CL_BSSN_convertToADMBaseDtLapseShiftBoundary_calc_offset" STEERABLE=ALWAYS
{
  *:* :: ""
} 0

restricted:
CCTK_INT CL_BSSN_constraints_calc_offset "CL_BSSN_constraints_calc_offset" STEERABLE=ALWAYS
{
  *:* :: ""
} 0

restricted:
CCTK_INT CL_BSSN_constraints_boundary_calc_offset "CL_BSSN_constraints_boundary_calc_offset" STEERABLE=ALWAYS
{
  *:* :: ""
} 0

private:
CCTK_KEYWORD phi_bound "Boundary condition to implement" STEERABLE=ALWAYS
{
  "flat" :: "Flat boundary condition"
  "none" :: "No boundary condition"
  "static" :: "Boundaries held fixed"
  "radiative" :: "Radiation boundary condition"
  "scalar" :: "Dirichlet boundary condition"
  "newrad" :: "Improved radiative boundary condition"
  "skip" :: "skip boundary condition code"
} "skip"

private:
CCTK_KEYWORD dphi1_bound "Boundary condition to implement" STEERABLE=ALWAYS
{
  "flat" :: "Flat boundary condition"
  "none" :: "No boundary condition"
  "static" :: "Boundaries held fixed"
  "radiative" :: "Radiation boundary condition"
  "scalar" :: "Dirichlet boundary condition"
  "newrad" :: "Improved radiative boundary condition"
  "skip" :: "skip boundary condition code"
} "skip"

private:
CCTK_KEYWORD dphi2_bound "Boundary condition to implement" STEERABLE=ALWAYS
{
  "flat" :: "Flat boundary condition"
  "none" :: "No boundary condition"
  "static" :: "Boundaries held fixed"
  "radiative" :: "Radiation boundary condition"
  "scalar" :: "Dirichlet boundary condition"
  "newrad" :: "Improved radiative boundary condition"
  "skip" :: "skip boundary condition code"
} "skip"

private:
CCTK_KEYWORD dphi3_bound "Boundary condition to implement" STEERABLE=ALWAYS
{
  "flat" :: "Flat boundary condition"
  "none" :: "No boundary condition"
  "static" :: "Boundaries held fixed"
  "radiative" :: "Radiation boundary condition"
  "scalar" :: "Dirichlet boundary condition"
  "newrad" :: "Improved radiative boundary condition"
  "skip" :: "skip boundary condition code"
} "skip"

private:
CCTK_KEYWORD gt11_bound "Boundary condition to implement" STEERABLE=ALWAYS
{
  "flat" :: "Flat boundary condition"
  "none" :: "No boundary condition"
  "static" :: "Boundaries held fixed"
  "radiative" :: "Radiation boundary condition"
  "scalar" :: "Dirichlet boundary condition"
  "newrad" :: "Improved radiative boundary condition"
  "skip" :: "skip boundary condition code"
} "skip"

private:
CCTK_KEYWORD gt12_bound "Boundary condition to implement" STEERABLE=ALWAYS
{
  "flat" :: "Flat boundary condition"
  "none" :: "No boundary condition"
  "static" :: "Boundaries held fixed"
  "radiative" :: "Radiation boundary condition"
  "scalar" :: "Dirichlet boundary condition"
  "newrad" :: "Improved radiative boundary condition"
  "skip" :: "skip boundary condition code"
} "skip"

private:
CCTK_KEYWORD gt13_bound "Boundary condition to implement" STEERABLE=ALWAYS
{
  "flat" :: "Flat boundary condition"
  "none" :: "No boundary condition"
  "static" :: "Boundaries held fixed"
  "radiative" :: "Radiation boundary condition"
  "scalar" :: "Dirichlet boundary condition"
  "newrad" :: "Improved radiative boundary condition"
  "skip" :: "skip boundary condition code"
} "skip"

private:
CCTK_KEYWORD gt22_bound "Boundary condition to implement" STEERABLE=ALWAYS
{
  "flat" :: "Flat boundary condition"
  "none" :: "No boundary condition"
  "static" :: "Boundaries held fixed"
  "radiative" :: "Radiation boundary condition"
  "scalar" :: "Dirichlet boundary condition"
  "newrad" :: "Improved radiative boundary condition"
  "skip" :: "skip boundary condition code"
} "skip"

private:
CCTK_KEYWORD gt23_bound "Boundary condition to implement" STEERABLE=ALWAYS
{
  "flat" :: "Flat boundary condition"
  "none" :: "No boundary condition"
  "static" :: "Boundaries held fixed"
  "radiative" :: "Radiation boundary condition"
  "scalar" :: "Dirichlet boundary condition"
  "newrad" :: "Improved radiative boundary condition"
  "skip" :: "skip boundary condition code"
} "skip"

private:
CCTK_KEYWORD gt33_bound "Boundary condition to implement" STEERABLE=ALWAYS
{
  "flat" :: "Flat boundary condition"
  "none" :: "No boundary condition"
  "static" :: "Boundaries held fixed"
  "radiative" :: "Radiation boundary condition"
  "scalar" :: "Dirichlet boundary condition"
  "newrad" :: "Improved radiative boundary condition"
  "skip" :: "skip boundary condition code"
} "skip"

private:
CCTK_KEYWORD dgt111_bound "Boundary condition to implement" STEERABLE=ALWAYS
{
  "flat" :: "Flat boundary condition"
  "none" :: "No boundary condition"
  "static" :: "Boundaries held fixed"
  "radiative" :: "Radiation boundary condition"
  "scalar" :: "Dirichlet boundary condition"
  "newrad" :: "Improved radiative boundary condition"
  "skip" :: "skip boundary condition code"
} "skip"

private:
CCTK_KEYWORD dgt112_bound "Boundary condition to implement" STEERABLE=ALWAYS
{
  "flat" :: "Flat boundary condition"
  "none" :: "No boundary condition"
  "static" :: "Boundaries held fixed"
  "radiative" :: "Radiation boundary condition"
  "scalar" :: "Dirichlet boundary condition"
  "newrad" :: "Improved radiative boundary condition"
  "skip" :: "skip boundary condition code"
} "skip"

private:
CCTK_KEYWORD dgt113_bound "Boundary condition to implement" STEERABLE=ALWAYS
{
  "flat" :: "Flat boundary condition"
  "none" :: "No boundary condition"
  "static" :: "Boundaries held fixed"
  "radiative" :: "Radiation boundary condition"
  "scalar" :: "Dirichlet boundary condition"
  "newrad" :: "Improved radiative boundary condition"
  "skip" :: "skip boundary condition code"
} "skip"

private:
CCTK_KEYWORD dgt122_bound "Boundary condition to implement" STEERABLE=ALWAYS
{
  "flat" :: "Flat boundary condition"
  "none" :: "No boundary condition"
  "static" :: "Boundaries held fixed"
  "radiative" :: "Radiation boundary condition"
  "scalar" :: "Dirichlet boundary condition"
  "newrad" :: "Improved radiative boundary condition"
  "skip" :: "skip boundary condition code"
} "skip"

private:
CCTK_KEYWORD dgt123_bound "Boundary condition to implement" STEERABLE=ALWAYS
{
  "flat" :: "Flat boundary condition"
  "none" :: "No boundary condition"
  "static" :: "Boundaries held fixed"
  "radiative" :: "Radiation boundary condition"
  "scalar" :: "Dirichlet boundary condition"
  "newrad" :: "Improved radiative boundary condition"
  "skip" :: "skip boundary condition code"
} "skip"

private:
CCTK_KEYWORD dgt133_bound "Boundary condition to implement" STEERABLE=ALWAYS
{
  "flat" :: "Flat boundary condition"
  "none" :: "No boundary condition"
  "static" :: "Boundaries held fixed"
  "radiative" :: "Radiation boundary condition"
  "scalar" :: "Dirichlet boundary condition"
  "newrad" :: "Improved radiative boundary condition"
  "skip" :: "skip boundary condition code"
} "skip"

private:
CCTK_KEYWORD dgt211_bound "Boundary condition to implement" STEERABLE=ALWAYS
{
  "flat" :: "Flat boundary condition"
  "none" :: "No boundary condition"
  "static" :: "Boundaries held fixed"
  "radiative" :: "Radiation boundary condition"
  "scalar" :: "Dirichlet boundary condition"
  "newrad" :: "Improved radiative boundary condition"
  "skip" :: "skip boundary condition code"
} "skip"

private:
CCTK_KEYWORD dgt212_bound "Boundary condition to implement" STEERABLE=ALWAYS
{
  "flat" :: "Flat boundary condition"
  "none" :: "No boundary condition"
  "static" :: "Boundaries held fixed"
  "radiative" :: "Radiation boundary condition"
  "scalar" :: "Dirichlet boundary condition"
  "newrad" :: "Improved radiative boundary condition"
  "skip" :: "skip boundary condition code"
} "skip"

private:
CCTK_KEYWORD dgt213_bound "Boundary condition to implement" STEERABLE=ALWAYS
{
  "flat" :: "Flat boundary condition"
  "none" :: "No boundary condition"
  "static" :: "Boundaries held fixed"
  "radiative" :: "Radiation boundary condition"
  "scalar" :: "Dirichlet boundary condition"
  "newrad" :: "Improved radiative boundary condition"
  "skip" :: "skip boundary condition code"
} "skip"

private:
CCTK_KEYWORD dgt222_bound "Boundary condition to implement" STEERABLE=ALWAYS
{
  "flat" :: "Flat boundary condition"
  "none" :: "No boundary condition"
  "static" :: "Boundaries held fixed"
  "radiative" :: "Radiation boundary condition"
  "scalar" :: "Dirichlet boundary condition"
  "newrad" :: "Improved radiative boundary condition"
  "skip" :: "skip boundary condition code"
} "skip"

private:
CCTK_KEYWORD dgt223_bound "Boundary condition to implement" STEERABLE=ALWAYS
{
  "flat" :: "Flat boundary condition"
  "none" :: "No boundary condition"
  "static" :: "Boundaries held fixed"
  "radiative" :: "Radiation boundary condition"
  "scalar" :: "Dirichlet boundary condition"
  "newrad" :: "Improved radiative boundary condition"
  "skip" :: "skip boundary condition code"
} "skip"

private:
CCTK_KEYWORD dgt233_bound "Boundary condition to implement" STEERABLE=ALWAYS
{
  "flat" :: "Flat boundary condition"
  "none" :: "No boundary condition"
  "static" :: "Boundaries held fixed"
  "radiative" :: "Radiation boundary condition"
  "scalar" :: "Dirichlet boundary condition"
  "newrad" :: "Improved radiative boundary condition"
  "skip" :: "skip boundary condition code"
} "skip"

private:
CCTK_KEYWORD dgt311_bound "Boundary condition to implement" STEERABLE=ALWAYS
{
  "flat" :: "Flat boundary condition"
  "none" :: "No boundary condition"
  "static" :: "Boundaries held fixed"
  "radiative" :: "Radiation boundary condition"
  "scalar" :: "Dirichlet boundary condition"
  "newrad" :: "Improved radiative boundary condition"
  "skip" :: "skip boundary condition code"
} "skip"

private:
CCTK_KEYWORD dgt312_bound "Boundary condition to implement" STEERABLE=ALWAYS
{
  "flat" :: "Flat boundary condition"
  "none" :: "No boundary condition"
  "static" :: "Boundaries held fixed"
  "radiative" :: "Radiation boundary condition"
  "scalar" :: "Dirichlet boundary condition"
  "newrad" :: "Improved radiative boundary condition"
  "skip" :: "skip boundary condition code"
} "skip"

private:
CCTK_KEYWORD dgt313_bound "Boundary condition to implement" STEERABLE=ALWAYS
{
  "flat" :: "Flat boundary condition"
  "none" :: "No boundary condition"
  "static" :: "Boundaries held fixed"
  "radiative" :: "Radiation boundary condition"
  "scalar" :: "Dirichlet boundary condition"
  "newrad" :: "Improved radiative boundary condition"
  "skip" :: "skip boundary condition code"
} "skip"

private:
CCTK_KEYWORD dgt322_bound "Boundary condition to implement" STEERABLE=ALWAYS
{
  "flat" :: "Flat boundary condition"
  "none" :: "No boundary condition"
  "static" :: "Boundaries held fixed"
  "radiative" :: "Radiation boundary condition"
  "scalar" :: "Dirichlet boundary condition"
  "newrad" :: "Improved radiative boundary condition"
  "skip" :: "skip boundary condition code"
} "skip"

private:
CCTK_KEYWORD dgt323_bound "Boundary condition to implement" STEERABLE=ALWAYS
{
  "flat" :: "Flat boundary condition"
  "none" :: "No boundary condition"
  "static" :: "Boundaries held fixed"
  "radiative" :: "Radiation boundary condition"
  "scalar" :: "Dirichlet boundary condition"
  "newrad" :: "Improved radiative boundary condition"
  "skip" :: "skip boundary condition code"
} "skip"

private:
CCTK_KEYWORD dgt333_bound "Boundary condition to implement" STEERABLE=ALWAYS
{
  "flat" :: "Flat boundary condition"
  "none" :: "No boundary condition"
  "static" :: "Boundaries held fixed"
  "radiative" :: "Radiation boundary condition"
  "scalar" :: "Dirichlet boundary condition"
  "newrad" :: "Improved radiative boundary condition"
  "skip" :: "skip boundary condition code"
} "skip"

private:
CCTK_KEYWORD Xt1_bound "Boundary condition to implement" STEERABLE=ALWAYS
{
  "flat" :: "Flat boundary condition"
  "none" :: "No boundary condition"
  "static" :: "Boundaries held fixed"
  "radiative" :: "Radiation boundary condition"
  "scalar" :: "Dirichlet boundary condition"
  "newrad" :: "Improved radiative boundary condition"
  "skip" :: "skip boundary condition code"
} "skip"

private:
CCTK_KEYWORD Xt2_bound "Boundary condition to implement" STEERABLE=ALWAYS
{
  "flat" :: "Flat boundary condition"
  "none" :: "No boundary condition"
  "static" :: "Boundaries held fixed"
  "radiative" :: "Radiation boundary condition"
  "scalar" :: "Dirichlet boundary condition"
  "newrad" :: "Improved radiative boundary condition"
  "skip" :: "skip boundary condition code"
} "skip"

private:
CCTK_KEYWORD Xt3_bound "Boundary condition to implement" STEERABLE=ALWAYS
{
  "flat" :: "Flat boundary condition"
  "none" :: "No boundary condition"
  "static" :: "Boundaries held fixed"
  "radiative" :: "Radiation boundary condition"
  "scalar" :: "Dirichlet boundary condition"
  "newrad" :: "Improved radiative boundary condition"
  "skip" :: "skip boundary condition code"
} "skip"

private:
CCTK_KEYWORD trK_bound "Boundary condition to implement" STEERABLE=ALWAYS
{
  "flat" :: "Flat boundary condition"
  "none" :: "No boundary condition"
  "static" :: "Boundaries held fixed"
  "radiative" :: "Radiation boundary condition"
  "scalar" :: "Dirichlet boundary condition"
  "newrad" :: "Improved radiative boundary condition"
  "skip" :: "skip boundary condition code"
} "skip"

private:
CCTK_KEYWORD At11_bound "Boundary condition to implement" STEERABLE=ALWAYS
{
  "flat" :: "Flat boundary condition"
  "none" :: "No boundary condition"
  "static" :: "Boundaries held fixed"
  "radiative" :: "Radiation boundary condition"
  "scalar" :: "Dirichlet boundary condition"
  "newrad" :: "Improved radiative boundary condition"
  "skip" :: "skip boundary condition code"
} "skip"

private:
CCTK_KEYWORD At12_bound "Boundary condition to implement" STEERABLE=ALWAYS
{
  "flat" :: "Flat boundary condition"
  "none" :: "No boundary condition"
  "static" :: "Boundaries held fixed"
  "radiative" :: "Radiation boundary condition"
  "scalar" :: "Dirichlet boundary condition"
  "newrad" :: "Improved radiative boundary condition"
  "skip" :: "skip boundary condition code"
} "skip"

private:
CCTK_KEYWORD At13_bound "Boundary condition to implement" STEERABLE=ALWAYS
{
  "flat" :: "Flat boundary condition"
  "none" :: "No boundary condition"
  "static" :: "Boundaries held fixed"
  "radiative" :: "Radiation boundary condition"
  "scalar" :: "Dirichlet boundary condition"
  "newrad" :: "Improved radiative boundary condition"
  "skip" :: "skip boundary condition code"
} "skip"

private:
CCTK_KEYWORD At22_bound "Boundary condition to implement" STEERABLE=ALWAYS
{
  "flat" :: "Flat boundary condition"
  "none" :: "No boundary condition"
  "static" :: "Boundaries held fixed"
  "radiative" :: "Radiation boundary condition"
  "scalar" :: "Dirichlet boundary condition"
  "newrad" :: "Improved radiative boundary condition"
  "skip" :: "skip boundary condition code"
} "skip"

private:
CCTK_KEYWORD At23_bound "Boundary condition to implement" STEERABLE=ALWAYS
{
  "flat" :: "Flat boundary condition"
  "none" :: "No boundary condition"
  "static" :: "Boundaries held fixed"
  "radiative" :: "Radiation boundary condition"
  "scalar" :: "Dirichlet boundary condition"
  "newrad" :: "Improved radiative boundary condition"
  "skip" :: "skip boundary condition code"
} "skip"

private:
CCTK_KEYWORD At33_bound "Boundary condition to implement" STEERABLE=ALWAYS
{
  "flat" :: "Flat boundary condition"
  "none" :: "No boundary condition"
  "static" :: "Boundaries held fixed"
  "radiative" :: "Radiation boundary condition"
  "scalar" :: "Dirichlet boundary condition"
  "newrad" :: "Improved radiative boundary condition"
  "skip" :: "skip boundary condition code"
} "skip"

private:
CCTK_KEYWORD alpha_bound "Boundary condition to implement" STEERABLE=ALWAYS
{
  "flat" :: "Flat boundary condition"
  "none" :: "No boundary condition"
  "static" :: "Boundaries held fixed"
  "radiative" :: "Radiation boundary condition"
  "scalar" :: "Dirichlet boundary condition"
  "newrad" :: "Improved radiative boundary condition"
  "skip" :: "skip boundary condition code"
} "skip"

private:
CCTK_KEYWORD dalpha1_bound "Boundary condition to implement" STEERABLE=ALWAYS
{
  "flat" :: "Flat boundary condition"
  "none" :: "No boundary condition"
  "static" :: "Boundaries held fixed"
  "radiative" :: "Radiation boundary condition"
  "scalar" :: "Dirichlet boundary condition"
  "newrad" :: "Improved radiative boundary condition"
  "skip" :: "skip boundary condition code"
} "skip"

private:
CCTK_KEYWORD dalpha2_bound "Boundary condition to implement" STEERABLE=ALWAYS
{
  "flat" :: "Flat boundary condition"
  "none" :: "No boundary condition"
  "static" :: "Boundaries held fixed"
  "radiative" :: "Radiation boundary condition"
  "scalar" :: "Dirichlet boundary condition"
  "newrad" :: "Improved radiative boundary condition"
  "skip" :: "skip boundary condition code"
} "skip"

private:
CCTK_KEYWORD dalpha3_bound "Boundary condition to implement" STEERABLE=ALWAYS
{
  "flat" :: "Flat boundary condition"
  "none" :: "No boundary condition"
  "static" :: "Boundaries held fixed"
  "radiative" :: "Radiation boundary condition"
  "scalar" :: "Dirichlet boundary condition"
  "newrad" :: "Improved radiative boundary condition"
  "skip" :: "skip boundary condition code"
} "skip"

private:
CCTK_KEYWORD beta1_bound "Boundary condition to implement" STEERABLE=ALWAYS
{
  "flat" :: "Flat boundary condition"
  "none" :: "No boundary condition"
  "static" :: "Boundaries held fixed"
  "radiative" :: "Radiation boundary condition"
  "scalar" :: "Dirichlet boundary condition"
  "newrad" :: "Improved radiative boundary condition"
  "skip" :: "skip boundary condition code"
} "skip"

private:
CCTK_KEYWORD beta2_bound "Boundary condition to implement" STEERABLE=ALWAYS
{
  "flat" :: "Flat boundary condition"
  "none" :: "No boundary condition"
  "static" :: "Boundaries held fixed"
  "radiative" :: "Radiation boundary condition"
  "scalar" :: "Dirichlet boundary condition"
  "newrad" :: "Improved radiative boundary condition"
  "skip" :: "skip boundary condition code"
} "skip"

private:
CCTK_KEYWORD beta3_bound "Boundary condition to implement" STEERABLE=ALWAYS
{
  "flat" :: "Flat boundary condition"
  "none" :: "No boundary condition"
  "static" :: "Boundaries held fixed"
  "radiative" :: "Radiation boundary condition"
  "scalar" :: "Dirichlet boundary condition"
  "newrad" :: "Improved radiative boundary condition"
  "skip" :: "skip boundary condition code"
} "skip"

private:
CCTK_KEYWORD dbeta11_bound "Boundary condition to implement" STEERABLE=ALWAYS
{
  "flat" :: "Flat boundary condition"
  "none" :: "No boundary condition"
  "static" :: "Boundaries held fixed"
  "radiative" :: "Radiation boundary condition"
  "scalar" :: "Dirichlet boundary condition"
  "newrad" :: "Improved radiative boundary condition"
  "skip" :: "skip boundary condition code"
} "skip"

private:
CCTK_KEYWORD dbeta12_bound "Boundary condition to implement" STEERABLE=ALWAYS
{
  "flat" :: "Flat boundary condition"
  "none" :: "No boundary condition"
  "static" :: "Boundaries held fixed"
  "radiative" :: "Radiation boundary condition"
  "scalar" :: "Dirichlet boundary condition"
  "newrad" :: "Improved radiative boundary condition"
  "skip" :: "skip boundary condition code"
} "skip"

private:
CCTK_KEYWORD dbeta13_bound "Boundary condition to implement" STEERABLE=ALWAYS
{
  "flat" :: "Flat boundary condition"
  "none" :: "No boundary condition"
  "static" :: "Boundaries held fixed"
  "radiative" :: "Radiation boundary condition"
  "scalar" :: "Dirichlet boundary condition"
  "newrad" :: "Improved radiative boundary condition"
  "skip" :: "skip boundary condition code"
} "skip"

private:
CCTK_KEYWORD dbeta21_bound "Boundary condition to implement" STEERABLE=ALWAYS
{
  "flat" :: "Flat boundary condition"
  "none" :: "No boundary condition"
  "static" :: "Boundaries held fixed"
  "radiative" :: "Radiation boundary condition"
  "scalar" :: "Dirichlet boundary condition"
  "newrad" :: "Improved radiative boundary condition"
  "skip" :: "skip boundary condition code"
} "skip"

private:
CCTK_KEYWORD dbeta22_bound "Boundary condition to implement" STEERABLE=ALWAYS
{
  "flat" :: "Flat boundary condition"
  "none" :: "No boundary condition"
  "static" :: "Boundaries held fixed"
  "radiative" :: "Radiation boundary condition"
  "scalar" :: "Dirichlet boundary condition"
  "newrad" :: "Improved radiative boundary condition"
  "skip" :: "skip boundary condition code"
} "skip"

private:
CCTK_KEYWORD dbeta23_bound "Boundary condition to implement" STEERABLE=ALWAYS
{
  "flat" :: "Flat boundary condition"
  "none" :: "No boundary condition"
  "static" :: "Boundaries held fixed"
  "radiative" :: "Radiation boundary condition"
  "scalar" :: "Dirichlet boundary condition"
  "newrad" :: "Improved radiative boundary condition"
  "skip" :: "skip boundary condition code"
} "skip"

private:
CCTK_KEYWORD dbeta31_bound "Boundary condition to implement" STEERABLE=ALWAYS
{
  "flat" :: "Flat boundary condition"
  "none" :: "No boundary condition"
  "static" :: "Boundaries held fixed"
  "radiative" :: "Radiation boundary condition"
  "scalar" :: "Dirichlet boundary condition"
  "newrad" :: "Improved radiative boundary condition"
  "skip" :: "skip boundary condition code"
} "skip"

private:
CCTK_KEYWORD dbeta32_bound "Boundary condition to implement" STEERABLE=ALWAYS
{
  "flat" :: "Flat boundary condition"
  "none" :: "No boundary condition"
  "static" :: "Boundaries held fixed"
  "radiative" :: "Radiation boundary condition"
  "scalar" :: "Dirichlet boundary condition"
  "newrad" :: "Improved radiative boundary condition"
  "skip" :: "skip boundary condition code"
} "skip"

private:
CCTK_KEYWORD dbeta33_bound "Boundary condition to implement" STEERABLE=ALWAYS
{
  "flat" :: "Flat boundary condition"
  "none" :: "No boundary condition"
  "static" :: "Boundaries held fixed"
  "radiative" :: "Radiation boundary condition"
  "scalar" :: "Dirichlet boundary condition"
  "newrad" :: "Improved radiative boundary condition"
  "skip" :: "skip boundary condition code"
} "skip"

private:
CCTK_KEYWORD B1_bound "Boundary condition to implement" STEERABLE=ALWAYS
{
  "flat" :: "Flat boundary condition"
  "none" :: "No boundary condition"
  "static" :: "Boundaries held fixed"
  "radiative" :: "Radiation boundary condition"
  "scalar" :: "Dirichlet boundary condition"
  "newrad" :: "Improved radiative boundary condition"
  "skip" :: "skip boundary condition code"
} "skip"

private:
CCTK_KEYWORD B2_bound "Boundary condition to implement" STEERABLE=ALWAYS
{
  "flat" :: "Flat boundary condition"
  "none" :: "No boundary condition"
  "static" :: "Boundaries held fixed"
  "radiative" :: "Radiation boundary condition"
  "scalar" :: "Dirichlet boundary condition"
  "newrad" :: "Improved radiative boundary condition"
  "skip" :: "skip boundary condition code"
} "skip"

private:
CCTK_KEYWORD B3_bound "Boundary condition to implement" STEERABLE=ALWAYS
{
  "flat" :: "Flat boundary condition"
  "none" :: "No boundary condition"
  "static" :: "Boundaries held fixed"
  "radiative" :: "Radiation boundary condition"
  "scalar" :: "Dirichlet boundary condition"
  "newrad" :: "Improved radiative boundary condition"
  "skip" :: "skip boundary condition code"
} "skip"

private:
CCTK_KEYWORD CL_log_confac_bound "Boundary condition to implement" STEERABLE=ALWAYS
{
  "flat" :: "Flat boundary condition"
  "none" :: "No boundary condition"
  "static" :: "Boundaries held fixed"
  "radiative" :: "Radiation boundary condition"
  "scalar" :: "Dirichlet boundary condition"
  "newrad" :: "Improved radiative boundary condition"
  "skip" :: "skip boundary condition code"
} "none"

private:
CCTK_KEYWORD CL_dlog_confac_bound "Boundary condition to implement" STEERABLE=ALWAYS
{
  "flat" :: "Flat boundary condition"
  "none" :: "No boundary condition"
  "static" :: "Boundaries held fixed"
  "radiative" :: "Radiation boundary condition"
  "scalar" :: "Dirichlet boundary condition"
  "newrad" :: "Improved radiative boundary condition"
  "skip" :: "skip boundary condition code"
} "none"

private:
CCTK_KEYWORD CL_metric_bound "Boundary condition to implement" STEERABLE=ALWAYS
{
  "flat" :: "Flat boundary condition"
  "none" :: "No boundary condition"
  "static" :: "Boundaries held fixed"
  "radiative" :: "Radiation boundary condition"
  "scalar" :: "Dirichlet boundary condition"
  "newrad" :: "Improved radiative boundary condition"
  "skip" :: "skip boundary condition code"
} "none"

private:
CCTK_KEYWORD CL_dmetric_bound "Boundary condition to implement" STEERABLE=ALWAYS
{
  "flat" :: "Flat boundary condition"
  "none" :: "No boundary condition"
  "static" :: "Boundaries held fixed"
  "radiative" :: "Radiation boundary condition"
  "scalar" :: "Dirichlet boundary condition"
  "newrad" :: "Improved radiative boundary condition"
  "skip" :: "skip boundary condition code"
} "none"

private:
CCTK_KEYWORD CL_Gamma_bound "Boundary condition to implement" STEERABLE=ALWAYS
{
  "flat" :: "Flat boundary condition"
  "none" :: "No boundary condition"
  "static" :: "Boundaries held fixed"
  "radiative" :: "Radiation boundary condition"
  "scalar" :: "Dirichlet boundary condition"
  "newrad" :: "Improved radiative boundary condition"
  "skip" :: "skip boundary condition code"
} "none"

private:
CCTK_KEYWORD CL_trace_curv_bound "Boundary condition to implement" STEERABLE=ALWAYS
{
  "flat" :: "Flat boundary condition"
  "none" :: "No boundary condition"
  "static" :: "Boundaries held fixed"
  "radiative" :: "Radiation boundary condition"
  "scalar" :: "Dirichlet boundary condition"
  "newrad" :: "Improved radiative boundary condition"
  "skip" :: "skip boundary condition code"
} "none"

private:
CCTK_KEYWORD CL_curv_bound "Boundary condition to implement" STEERABLE=ALWAYS
{
  "flat" :: "Flat boundary condition"
  "none" :: "No boundary condition"
  "static" :: "Boundaries held fixed"
  "radiative" :: "Radiation boundary condition"
  "scalar" :: "Dirichlet boundary condition"
  "newrad" :: "Improved radiative boundary condition"
  "skip" :: "skip boundary condition code"
} "none"

private:
CCTK_KEYWORD CL_lapse_bound "Boundary condition to implement" STEERABLE=ALWAYS
{
  "flat" :: "Flat boundary condition"
  "none" :: "No boundary condition"
  "static" :: "Boundaries held fixed"
  "radiative" :: "Radiation boundary condition"
  "scalar" :: "Dirichlet boundary condition"
  "newrad" :: "Improved radiative boundary condition"
  "skip" :: "skip boundary condition code"
} "none"

private:
CCTK_KEYWORD CL_dlapse_bound "Boundary condition to implement" STEERABLE=ALWAYS
{
  "flat" :: "Flat boundary condition"
  "none" :: "No boundary condition"
  "static" :: "Boundaries held fixed"
  "radiative" :: "Radiation boundary condition"
  "scalar" :: "Dirichlet boundary condition"
  "newrad" :: "Improved radiative boundary condition"
  "skip" :: "skip boundary condition code"
} "none"

private:
CCTK_KEYWORD CL_shift_bound "Boundary condition to implement" STEERABLE=ALWAYS
{
  "flat" :: "Flat boundary condition"
  "none" :: "No boundary condition"
  "static" :: "Boundaries held fixed"
  "radiative" :: "Radiation boundary condition"
  "scalar" :: "Dirichlet boundary condition"
  "newrad" :: "Improved radiative boundary condition"
  "skip" :: "skip boundary condition code"
} "none"

private:
CCTK_KEYWORD CL_dshift_bound "Boundary condition to implement" STEERABLE=ALWAYS
{
  "flat" :: "Flat boundary condition"
  "none" :: "No boundary condition"
  "static" :: "Boundaries held fixed"
  "radiative" :: "Radiation boundary condition"
  "scalar" :: "Dirichlet boundary condition"
  "newrad" :: "Improved radiative boundary condition"
  "skip" :: "skip boundary condition code"
} "none"

private:
CCTK_KEYWORD CL_dtshift_bound "Boundary condition to implement" STEERABLE=ALWAYS
{
  "flat" :: "Flat boundary condition"
  "none" :: "No boundary condition"
  "static" :: "Boundaries held fixed"
  "radiative" :: "Radiation boundary condition"
  "scalar" :: "Dirichlet boundary condition"
  "newrad" :: "Improved radiative boundary condition"
  "skip" :: "skip boundary condition code"
} "none"

private:
CCTK_REAL phi_bound_speed "characteristic speed at boundary" STEERABLE=ALWAYS
{
  0:* :: "outgoing characteristic speed > 0"
} 1.

private:
CCTK_REAL dphi1_bound_speed "characteristic speed at boundary" STEERABLE=ALWAYS
{
  0:* :: "outgoing characteristic speed > 0"
} 1.

private:
CCTK_REAL dphi2_bound_speed "characteristic speed at boundary" STEERABLE=ALWAYS
{
  0:* :: "outgoing characteristic speed > 0"
} 1.

private:
CCTK_REAL dphi3_bound_speed "characteristic speed at boundary" STEERABLE=ALWAYS
{
  0:* :: "outgoing characteristic speed > 0"
} 1.

private:
CCTK_REAL gt11_bound_speed "characteristic speed at boundary" STEERABLE=ALWAYS
{
  0:* :: "outgoing characteristic speed > 0"
} 1.

private:
CCTK_REAL gt12_bound_speed "characteristic speed at boundary" STEERABLE=ALWAYS
{
  0:* :: "outgoing characteristic speed > 0"
} 1.

private:
CCTK_REAL gt13_bound_speed "characteristic speed at boundary" STEERABLE=ALWAYS
{
  0:* :: "outgoing characteristic speed > 0"
} 1.

private:
CCTK_REAL gt22_bound_speed "characteristic speed at boundary" STEERABLE=ALWAYS
{
  0:* :: "outgoing characteristic speed > 0"
} 1.

private:
CCTK_REAL gt23_bound_speed "characteristic speed at boundary" STEERABLE=ALWAYS
{
  0:* :: "outgoing characteristic speed > 0"
} 1.

private:
CCTK_REAL gt33_bound_speed "characteristic speed at boundary" STEERABLE=ALWAYS
{
  0:* :: "outgoing characteristic speed > 0"
} 1.

private:
CCTK_REAL dgt111_bound_speed "characteristic speed at boundary" STEERABLE=ALWAYS
{
  0:* :: "outgoing characteristic speed > 0"
} 1.

private:
CCTK_REAL dgt112_bound_speed "characteristic speed at boundary" STEERABLE=ALWAYS
{
  0:* :: "outgoing characteristic speed > 0"
} 1.

private:
CCTK_REAL dgt113_bound_speed "characteristic speed at boundary" STEERABLE=ALWAYS
{
  0:* :: "outgoing characteristic speed > 0"
} 1.

private:
CCTK_REAL dgt122_bound_speed "characteristic speed at boundary" STEERABLE=ALWAYS
{
  0:* :: "outgoing characteristic speed > 0"
} 1.

private:
CCTK_REAL dgt123_bound_speed "characteristic speed at boundary" STEERABLE=ALWAYS
{
  0:* :: "outgoing characteristic speed > 0"
} 1.

private:
CCTK_REAL dgt133_bound_speed "characteristic speed at boundary" STEERABLE=ALWAYS
{
  0:* :: "outgoing characteristic speed > 0"
} 1.

private:
CCTK_REAL dgt211_bound_speed "characteristic speed at boundary" STEERABLE=ALWAYS
{
  0:* :: "outgoing characteristic speed > 0"
} 1.

private:
CCTK_REAL dgt212_bound_speed "characteristic speed at boundary" STEERABLE=ALWAYS
{
  0:* :: "outgoing characteristic speed > 0"
} 1.

private:
CCTK_REAL dgt213_bound_speed "characteristic speed at boundary" STEERABLE=ALWAYS
{
  0:* :: "outgoing characteristic speed > 0"
} 1.

private:
CCTK_REAL dgt222_bound_speed "characteristic speed at boundary" STEERABLE=ALWAYS
{
  0:* :: "outgoing characteristic speed > 0"
} 1.

private:
CCTK_REAL dgt223_bound_speed "characteristic speed at boundary" STEERABLE=ALWAYS
{
  0:* :: "outgoing characteristic speed > 0"
} 1.

private:
CCTK_REAL dgt233_bound_speed "characteristic speed at boundary" STEERABLE=ALWAYS
{
  0:* :: "outgoing characteristic speed > 0"
} 1.

private:
CCTK_REAL dgt311_bound_speed "characteristic speed at boundary" STEERABLE=ALWAYS
{
  0:* :: "outgoing characteristic speed > 0"
} 1.

private:
CCTK_REAL dgt312_bound_speed "characteristic speed at boundary" STEERABLE=ALWAYS
{
  0:* :: "outgoing characteristic speed > 0"
} 1.

private:
CCTK_REAL dgt313_bound_speed "characteristic speed at boundary" STEERABLE=ALWAYS
{
  0:* :: "outgoing characteristic speed > 0"
} 1.

private:
CCTK_REAL dgt322_bound_speed "characteristic speed at boundary" STEERABLE=ALWAYS
{
  0:* :: "outgoing characteristic speed > 0"
} 1.

private:
CCTK_REAL dgt323_bound_speed "characteristic speed at boundary" STEERABLE=ALWAYS
{
  0:* :: "outgoing characteristic speed > 0"
} 1.

private:
CCTK_REAL dgt333_bound_speed "characteristic speed at boundary" STEERABLE=ALWAYS
{
  0:* :: "outgoing characteristic speed > 0"
} 1.

private:
CCTK_REAL Xt1_bound_speed "characteristic speed at boundary" STEERABLE=ALWAYS
{
  0:* :: "outgoing characteristic speed > 0"
} 1.

private:
CCTK_REAL Xt2_bound_speed "characteristic speed at boundary" STEERABLE=ALWAYS
{
  0:* :: "outgoing characteristic speed > 0"
} 1.

private:
CCTK_REAL Xt3_bound_speed "characteristic speed at boundary" STEERABLE=ALWAYS
{
  0:* :: "outgoing characteristic speed > 0"
} 1.

private:
CCTK_REAL trK_bound_speed "characteristic speed at boundary" STEERABLE=ALWAYS
{
  0:* :: "outgoing characteristic speed > 0"
} 1.

private:
CCTK_REAL At11_bound_speed "characteristic speed at boundary" STEERABLE=ALWAYS
{
  0:* :: "outgoing characteristic speed > 0"
} 1.

private:
CCTK_REAL At12_bound_speed "characteristic speed at boundary" STEERABLE=ALWAYS
{
  0:* :: "outgoing characteristic speed > 0"
} 1.

private:
CCTK_REAL At13_bound_speed "characteristic speed at boundary" STEERABLE=ALWAYS
{
  0:* :: "outgoing characteristic speed > 0"
} 1.

private:
CCTK_REAL At22_bound_speed "characteristic speed at boundary" STEERABLE=ALWAYS
{
  0:* :: "outgoing characteristic speed > 0"
} 1.

private:
CCTK_REAL At23_bound_speed "characteristic speed at boundary" STEERABLE=ALWAYS
{
  0:* :: "outgoing characteristic speed > 0"
} 1.

private:
CCTK_REAL At33_bound_speed "characteristic speed at boundary" STEERABLE=ALWAYS
{
  0:* :: "outgoing characteristic speed > 0"
} 1.

private:
CCTK_REAL alpha_bound_speed "characteristic speed at boundary" STEERABLE=ALWAYS
{
  0:* :: "outgoing characteristic speed > 0"
} 1.

private:
CCTK_REAL dalpha1_bound_speed "characteristic speed at boundary" STEERABLE=ALWAYS
{
  0:* :: "outgoing characteristic speed > 0"
} 1.

private:
CCTK_REAL dalpha2_bound_speed "characteristic speed at boundary" STEERABLE=ALWAYS
{
  0:* :: "outgoing characteristic speed > 0"
} 1.

private:
CCTK_REAL dalpha3_bound_speed "characteristic speed at boundary" STEERABLE=ALWAYS
{
  0:* :: "outgoing characteristic speed > 0"
} 1.

private:
CCTK_REAL beta1_bound_speed "characteristic speed at boundary" STEERABLE=ALWAYS
{
  0:* :: "outgoing characteristic speed > 0"
} 1.

private:
CCTK_REAL beta2_bound_speed "characteristic speed at boundary" STEERABLE=ALWAYS
{
  0:* :: "outgoing characteristic speed > 0"
} 1.

private:
CCTK_REAL beta3_bound_speed "characteristic speed at boundary" STEERABLE=ALWAYS
{
  0:* :: "outgoing characteristic speed > 0"
} 1.

private:
CCTK_REAL dbeta11_bound_speed "characteristic speed at boundary" STEERABLE=ALWAYS
{
  0:* :: "outgoing characteristic speed > 0"
} 1.

private:
CCTK_REAL dbeta12_bound_speed "characteristic speed at boundary" STEERABLE=ALWAYS
{
  0:* :: "outgoing characteristic speed > 0"
} 1.

private:
CCTK_REAL dbeta13_bound_speed "characteristic speed at boundary" STEERABLE=ALWAYS
{
  0:* :: "outgoing characteristic speed > 0"
} 1.

private:
CCTK_REAL dbeta21_bound_speed "characteristic speed at boundary" STEERABLE=ALWAYS
{
  0:* :: "outgoing characteristic speed > 0"
} 1.

private:
CCTK_REAL dbeta22_bound_speed "characteristic speed at boundary" STEERABLE=ALWAYS
{
  0:* :: "outgoing characteristic speed > 0"
} 1.

private:
CCTK_REAL dbeta23_bound_speed "characteristic speed at boundary" STEERABLE=ALWAYS
{
  0:* :: "outgoing characteristic speed > 0"
} 1.

private:
CCTK_REAL dbeta31_bound_speed "characteristic speed at boundary" STEERABLE=ALWAYS
{
  0:* :: "outgoing characteristic speed > 0"
} 1.

private:
CCTK_REAL dbeta32_bound_speed "characteristic speed at boundary" STEERABLE=ALWAYS
{
  0:* :: "outgoing characteristic speed > 0"
} 1.

private:
CCTK_REAL dbeta33_bound_speed "characteristic speed at boundary" STEERABLE=ALWAYS
{
  0:* :: "outgoing characteristic speed > 0"
} 1.

private:
CCTK_REAL B1_bound_speed "characteristic speed at boundary" STEERABLE=ALWAYS
{
  0:* :: "outgoing characteristic speed > 0"
} 1.

private:
CCTK_REAL B2_bound_speed "characteristic speed at boundary" STEERABLE=ALWAYS
{
  0:* :: "outgoing characteristic speed > 0"
} 1.

private:
CCTK_REAL B3_bound_speed "characteristic speed at boundary" STEERABLE=ALWAYS
{
  0:* :: "outgoing characteristic speed > 0"
} 1.

private:
CCTK_REAL CL_log_confac_bound_speed "characteristic speed at boundary" STEERABLE=ALWAYS
{
  0:* :: "outgoing characteristic speed > 0"
} 1.

private:
CCTK_REAL CL_dlog_confac_bound_speed "characteristic speed at boundary" STEERABLE=ALWAYS
{
  0:* :: "outgoing characteristic speed > 0"
} 1.

private:
CCTK_REAL CL_metric_bound_speed "characteristic speed at boundary" STEERABLE=ALWAYS
{
  0:* :: "outgoing characteristic speed > 0"
} 1.

private:
CCTK_REAL CL_dmetric_bound_speed "characteristic speed at boundary" STEERABLE=ALWAYS
{
  0:* :: "outgoing characteristic speed > 0"
} 1.

private:
CCTK_REAL CL_Gamma_bound_speed "characteristic speed at boundary" STEERABLE=ALWAYS
{
  0:* :: "outgoing characteristic speed > 0"
} 1.

private:
CCTK_REAL CL_trace_curv_bound_speed "characteristic speed at boundary" STEERABLE=ALWAYS
{
  0:* :: "outgoing characteristic speed > 0"
} 1.

private:
CCTK_REAL CL_curv_bound_speed "characteristic speed at boundary" STEERABLE=ALWAYS
{
  0:* :: "outgoing characteristic speed > 0"
} 1.

private:
CCTK_REAL CL_lapse_bound_speed "characteristic speed at boundary" STEERABLE=ALWAYS
{
  0:* :: "outgoing characteristic speed > 0"
} 1.

private:
CCTK_REAL CL_dlapse_bound_speed "characteristic speed at boundary" STEERABLE=ALWAYS
{
  0:* :: "outgoing characteristic speed > 0"
} 1.

private:
CCTK_REAL CL_shift_bound_speed "characteristic speed at boundary" STEERABLE=ALWAYS
{
  0:* :: "outgoing characteristic speed > 0"
} 1.

private:
CCTK_REAL CL_dshift_bound_speed "characteristic speed at boundary" STEERABLE=ALWAYS
{
  0:* :: "outgoing characteristic speed > 0"
} 1.

private:
CCTK_REAL CL_dtshift_bound_speed "characteristic speed at boundary" STEERABLE=ALWAYS
{
  0:* :: "outgoing characteristic speed > 0"
} 1.

private:
CCTK_REAL phi_bound_limit "limit value for r -> infinity" STEERABLE=ALWAYS
{
  *:* :: "value of limit value is unrestricted"
} 0.

private:
CCTK_REAL dphi1_bound_limit "limit value for r -> infinity" STEERABLE=ALWAYS
{
  *:* :: "value of limit value is unrestricted"
} 0.

private:
CCTK_REAL dphi2_bound_limit "limit value for r -> infinity" STEERABLE=ALWAYS
{
  *:* :: "value of limit value is unrestricted"
} 0.

private:
CCTK_REAL dphi3_bound_limit "limit value for r -> infinity" STEERABLE=ALWAYS
{
  *:* :: "value of limit value is unrestricted"
} 0.

private:
CCTK_REAL gt11_bound_limit "limit value for r -> infinity" STEERABLE=ALWAYS
{
  *:* :: "value of limit value is unrestricted"
} 0.

private:
CCTK_REAL gt12_bound_limit "limit value for r -> infinity" STEERABLE=ALWAYS
{
  *:* :: "value of limit value is unrestricted"
} 0.

private:
CCTK_REAL gt13_bound_limit "limit value for r -> infinity" STEERABLE=ALWAYS
{
  *:* :: "value of limit value is unrestricted"
} 0.

private:
CCTK_REAL gt22_bound_limit "limit value for r -> infinity" STEERABLE=ALWAYS
{
  *:* :: "value of limit value is unrestricted"
} 0.

private:
CCTK_REAL gt23_bound_limit "limit value for r -> infinity" STEERABLE=ALWAYS
{
  *:* :: "value of limit value is unrestricted"
} 0.

private:
CCTK_REAL gt33_bound_limit "limit value for r -> infinity" STEERABLE=ALWAYS
{
  *:* :: "value of limit value is unrestricted"
} 0.

private:
CCTK_REAL dgt111_bound_limit "limit value for r -> infinity" STEERABLE=ALWAYS
{
  *:* :: "value of limit value is unrestricted"
} 0.

private:
CCTK_REAL dgt112_bound_limit "limit value for r -> infinity" STEERABLE=ALWAYS
{
  *:* :: "value of limit value is unrestricted"
} 0.

private:
CCTK_REAL dgt113_bound_limit "limit value for r -> infinity" STEERABLE=ALWAYS
{
  *:* :: "value of limit value is unrestricted"
} 0.

private:
CCTK_REAL dgt122_bound_limit "limit value for r -> infinity" STEERABLE=ALWAYS
{
  *:* :: "value of limit value is unrestricted"
} 0.

private:
CCTK_REAL dgt123_bound_limit "limit value for r -> infinity" STEERABLE=ALWAYS
{
  *:* :: "value of limit value is unrestricted"
} 0.

private:
CCTK_REAL dgt133_bound_limit "limit value for r -> infinity" STEERABLE=ALWAYS
{
  *:* :: "value of limit value is unrestricted"
} 0.

private:
CCTK_REAL dgt211_bound_limit "limit value for r -> infinity" STEERABLE=ALWAYS
{
  *:* :: "value of limit value is unrestricted"
} 0.

private:
CCTK_REAL dgt212_bound_limit "limit value for r -> infinity" STEERABLE=ALWAYS
{
  *:* :: "value of limit value is unrestricted"
} 0.

private:
CCTK_REAL dgt213_bound_limit "limit value for r -> infinity" STEERABLE=ALWAYS
{
  *:* :: "value of limit value is unrestricted"
} 0.

private:
CCTK_REAL dgt222_bound_limit "limit value for r -> infinity" STEERABLE=ALWAYS
{
  *:* :: "value of limit value is unrestricted"
} 0.

private:
CCTK_REAL dgt223_bound_limit "limit value for r -> infinity" STEERABLE=ALWAYS
{
  *:* :: "value of limit value is unrestricted"
} 0.

private:
CCTK_REAL dgt233_bound_limit "limit value for r -> infinity" STEERABLE=ALWAYS
{
  *:* :: "value of limit value is unrestricted"
} 0.

private:
CCTK_REAL dgt311_bound_limit "limit value for r -> infinity" STEERABLE=ALWAYS
{
  *:* :: "value of limit value is unrestricted"
} 0.

private:
CCTK_REAL dgt312_bound_limit "limit value for r -> infinity" STEERABLE=ALWAYS
{
  *:* :: "value of limit value is unrestricted"
} 0.

private:
CCTK_REAL dgt313_bound_limit "limit value for r -> infinity" STEERABLE=ALWAYS
{
  *:* :: "value of limit value is unrestricted"
} 0.

private:
CCTK_REAL dgt322_bound_limit "limit value for r -> infinity" STEERABLE=ALWAYS
{
  *:* :: "value of limit value is unrestricted"
} 0.

private:
CCTK_REAL dgt323_bound_limit "limit value for r -> infinity" STEERABLE=ALWAYS
{
  *:* :: "value of limit value is unrestricted"
} 0.

private:
CCTK_REAL dgt333_bound_limit "limit value for r -> infinity" STEERABLE=ALWAYS
{
  *:* :: "value of limit value is unrestricted"
} 0.

private:
CCTK_REAL Xt1_bound_limit "limit value for r -> infinity" STEERABLE=ALWAYS
{
  *:* :: "value of limit value is unrestricted"
} 0.

private:
CCTK_REAL Xt2_bound_limit "limit value for r -> infinity" STEERABLE=ALWAYS
{
  *:* :: "value of limit value is unrestricted"
} 0.

private:
CCTK_REAL Xt3_bound_limit "limit value for r -> infinity" STEERABLE=ALWAYS
{
  *:* :: "value of limit value is unrestricted"
} 0.

private:
CCTK_REAL trK_bound_limit "limit value for r -> infinity" STEERABLE=ALWAYS
{
  *:* :: "value of limit value is unrestricted"
} 0.

private:
CCTK_REAL At11_bound_limit "limit value for r -> infinity" STEERABLE=ALWAYS
{
  *:* :: "value of limit value is unrestricted"
} 0.

private:
CCTK_REAL At12_bound_limit "limit value for r -> infinity" STEERABLE=ALWAYS
{
  *:* :: "value of limit value is unrestricted"
} 0.

private:
CCTK_REAL At13_bound_limit "limit value for r -> infinity" STEERABLE=ALWAYS
{
  *:* :: "value of limit value is unrestricted"
} 0.

private:
CCTK_REAL At22_bound_limit "limit value for r -> infinity" STEERABLE=ALWAYS
{
  *:* :: "value of limit value is unrestricted"
} 0.

private:
CCTK_REAL At23_bound_limit "limit value for r -> infinity" STEERABLE=ALWAYS
{
  *:* :: "value of limit value is unrestricted"
} 0.

private:
CCTK_REAL At33_bound_limit "limit value for r -> infinity" STEERABLE=ALWAYS
{
  *:* :: "value of limit value is unrestricted"
} 0.

private:
CCTK_REAL alpha_bound_limit "limit value for r -> infinity" STEERABLE=ALWAYS
{
  *:* :: "value of limit value is unrestricted"
} 0.

private:
CCTK_REAL dalpha1_bound_limit "limit value for r -> infinity" STEERABLE=ALWAYS
{
  *:* :: "value of limit value is unrestricted"
} 0.

private:
CCTK_REAL dalpha2_bound_limit "limit value for r -> infinity" STEERABLE=ALWAYS
{
  *:* :: "value of limit value is unrestricted"
} 0.

private:
CCTK_REAL dalpha3_bound_limit "limit value for r -> infinity" STEERABLE=ALWAYS
{
  *:* :: "value of limit value is unrestricted"
} 0.

private:
CCTK_REAL beta1_bound_limit "limit value for r -> infinity" STEERABLE=ALWAYS
{
  *:* :: "value of limit value is unrestricted"
} 0.

private:
CCTK_REAL beta2_bound_limit "limit value for r -> infinity" STEERABLE=ALWAYS
{
  *:* :: "value of limit value is unrestricted"
} 0.

private:
CCTK_REAL beta3_bound_limit "limit value for r -> infinity" STEERABLE=ALWAYS
{
  *:* :: "value of limit value is unrestricted"
} 0.

private:
CCTK_REAL dbeta11_bound_limit "limit value for r -> infinity" STEERABLE=ALWAYS
{
  *:* :: "value of limit value is unrestricted"
} 0.

private:
CCTK_REAL dbeta12_bound_limit "limit value for r -> infinity" STEERABLE=ALWAYS
{
  *:* :: "value of limit value is unrestricted"
} 0.

private:
CCTK_REAL dbeta13_bound_limit "limit value for r -> infinity" STEERABLE=ALWAYS
{
  *:* :: "value of limit value is unrestricted"
} 0.

private:
CCTK_REAL dbeta21_bound_limit "limit value for r -> infinity" STEERABLE=ALWAYS
{
  *:* :: "value of limit value is unrestricted"
} 0.

private:
CCTK_REAL dbeta22_bound_limit "limit value for r -> infinity" STEERABLE=ALWAYS
{
  *:* :: "value of limit value is unrestricted"
} 0.

private:
CCTK_REAL dbeta23_bound_limit "limit value for r -> infinity" STEERABLE=ALWAYS
{
  *:* :: "value of limit value is unrestricted"
} 0.

private:
CCTK_REAL dbeta31_bound_limit "limit value for r -> infinity" STEERABLE=ALWAYS
{
  *:* :: "value of limit value is unrestricted"
} 0.

private:
CCTK_REAL dbeta32_bound_limit "limit value for r -> infinity" STEERABLE=ALWAYS
{
  *:* :: "value of limit value is unrestricted"
} 0.

private:
CCTK_REAL dbeta33_bound_limit "limit value for r -> infinity" STEERABLE=ALWAYS
{
  *:* :: "value of limit value is unrestricted"
} 0.

private:
CCTK_REAL B1_bound_limit "limit value for r -> infinity" STEERABLE=ALWAYS
{
  *:* :: "value of limit value is unrestricted"
} 0.

private:
CCTK_REAL B2_bound_limit "limit value for r -> infinity" STEERABLE=ALWAYS
{
  *:* :: "value of limit value is unrestricted"
} 0.

private:
CCTK_REAL B3_bound_limit "limit value for r -> infinity" STEERABLE=ALWAYS
{
  *:* :: "value of limit value is unrestricted"
} 0.

private:
CCTK_REAL CL_log_confac_bound_limit "limit value for r -> infinity" STEERABLE=ALWAYS
{
  *:* :: "value of limit value is unrestricted"
} 0.

private:
CCTK_REAL CL_dlog_confac_bound_limit "limit value for r -> infinity" STEERABLE=ALWAYS
{
  *:* :: "value of limit value is unrestricted"
} 0.

private:
CCTK_REAL CL_metric_bound_limit "limit value for r -> infinity" STEERABLE=ALWAYS
{
  *:* :: "value of limit value is unrestricted"
} 0.

private:
CCTK_REAL CL_dmetric_bound_limit "limit value for r -> infinity" STEERABLE=ALWAYS
{
  *:* :: "value of limit value is unrestricted"
} 0.

private:
CCTK_REAL CL_Gamma_bound_limit "limit value for r -> infinity" STEERABLE=ALWAYS
{
  *:* :: "value of limit value is unrestricted"
} 0.

private:
CCTK_REAL CL_trace_curv_bound_limit "limit value for r -> infinity" STEERABLE=ALWAYS
{
  *:* :: "value of limit value is unrestricted"
} 0.

private:
CCTK_REAL CL_curv_bound_limit "limit value for r -> infinity" STEERABLE=ALWAYS
{
  *:* :: "value of limit value is unrestricted"
} 0.

private:
CCTK_REAL CL_lapse_bound_limit "limit value for r -> infinity" STEERABLE=ALWAYS
{
  *:* :: "value of limit value is unrestricted"
} 0.

private:
CCTK_REAL CL_dlapse_bound_limit "limit value for r -> infinity" STEERABLE=ALWAYS
{
  *:* :: "value of limit value is unrestricted"
} 0.

private:
CCTK_REAL CL_shift_bound_limit "limit value for r -> infinity" STEERABLE=ALWAYS
{
  *:* :: "value of limit value is unrestricted"
} 0.

private:
CCTK_REAL CL_dshift_bound_limit "limit value for r -> infinity" STEERABLE=ALWAYS
{
  *:* :: "value of limit value is unrestricted"
} 0.

private:
CCTK_REAL CL_dtshift_bound_limit "limit value for r -> infinity" STEERABLE=ALWAYS
{
  *:* :: "value of limit value is unrestricted"
} 0.

private:
CCTK_REAL phi_bound_scalar "Dirichlet boundary value" STEERABLE=ALWAYS
{
  *:* :: "unrestricted"
} 0.

private:
CCTK_REAL dphi1_bound_scalar "Dirichlet boundary value" STEERABLE=ALWAYS
{
  *:* :: "unrestricted"
} 0.

private:
CCTK_REAL dphi2_bound_scalar "Dirichlet boundary value" STEERABLE=ALWAYS
{
  *:* :: "unrestricted"
} 0.

private:
CCTK_REAL dphi3_bound_scalar "Dirichlet boundary value" STEERABLE=ALWAYS
{
  *:* :: "unrestricted"
} 0.

private:
CCTK_REAL gt11_bound_scalar "Dirichlet boundary value" STEERABLE=ALWAYS
{
  *:* :: "unrestricted"
} 0.

private:
CCTK_REAL gt12_bound_scalar "Dirichlet boundary value" STEERABLE=ALWAYS
{
  *:* :: "unrestricted"
} 0.

private:
CCTK_REAL gt13_bound_scalar "Dirichlet boundary value" STEERABLE=ALWAYS
{
  *:* :: "unrestricted"
} 0.

private:
CCTK_REAL gt22_bound_scalar "Dirichlet boundary value" STEERABLE=ALWAYS
{
  *:* :: "unrestricted"
} 0.

private:
CCTK_REAL gt23_bound_scalar "Dirichlet boundary value" STEERABLE=ALWAYS
{
  *:* :: "unrestricted"
} 0.

private:
CCTK_REAL gt33_bound_scalar "Dirichlet boundary value" STEERABLE=ALWAYS
{
  *:* :: "unrestricted"
} 0.

private:
CCTK_REAL dgt111_bound_scalar "Dirichlet boundary value" STEERABLE=ALWAYS
{
  *:* :: "unrestricted"
} 0.

private:
CCTK_REAL dgt112_bound_scalar "Dirichlet boundary value" STEERABLE=ALWAYS
{
  *:* :: "unrestricted"
} 0.

private:
CCTK_REAL dgt113_bound_scalar "Dirichlet boundary value" STEERABLE=ALWAYS
{
  *:* :: "unrestricted"
} 0.

private:
CCTK_REAL dgt122_bound_scalar "Dirichlet boundary value" STEERABLE=ALWAYS
{
  *:* :: "unrestricted"
} 0.

private:
CCTK_REAL dgt123_bound_scalar "Dirichlet boundary value" STEERABLE=ALWAYS
{
  *:* :: "unrestricted"
} 0.

private:
CCTK_REAL dgt133_bound_scalar "Dirichlet boundary value" STEERABLE=ALWAYS
{
  *:* :: "unrestricted"
} 0.

private:
CCTK_REAL dgt211_bound_scalar "Dirichlet boundary value" STEERABLE=ALWAYS
{
  *:* :: "unrestricted"
} 0.

private:
CCTK_REAL dgt212_bound_scalar "Dirichlet boundary value" STEERABLE=ALWAYS
{
  *:* :: "unrestricted"
} 0.

private:
CCTK_REAL dgt213_bound_scalar "Dirichlet boundary value" STEERABLE=ALWAYS
{
  *:* :: "unrestricted"
} 0.

private:
CCTK_REAL dgt222_bound_scalar "Dirichlet boundary value" STEERABLE=ALWAYS
{
  *:* :: "unrestricted"
} 0.

private:
CCTK_REAL dgt223_bound_scalar "Dirichlet boundary value" STEERABLE=ALWAYS
{
  *:* :: "unrestricted"
} 0.

private:
CCTK_REAL dgt233_bound_scalar "Dirichlet boundary value" STEERABLE=ALWAYS
{
  *:* :: "unrestricted"
} 0.

private:
CCTK_REAL dgt311_bound_scalar "Dirichlet boundary value" STEERABLE=ALWAYS
{
  *:* :: "unrestricted"
} 0.

private:
CCTK_REAL dgt312_bound_scalar "Dirichlet boundary value" STEERABLE=ALWAYS
{
  *:* :: "unrestricted"
} 0.

private:
CCTK_REAL dgt313_bound_scalar "Dirichlet boundary value" STEERABLE=ALWAYS
{
  *:* :: "unrestricted"
} 0.

private:
CCTK_REAL dgt322_bound_scalar "Dirichlet boundary value" STEERABLE=ALWAYS
{
  *:* :: "unrestricted"
} 0.

private:
CCTK_REAL dgt323_bound_scalar "Dirichlet boundary value" STEERABLE=ALWAYS
{
  *:* :: "unrestricted"
} 0.

private:
CCTK_REAL dgt333_bound_scalar "Dirichlet boundary value" STEERABLE=ALWAYS
{
  *:* :: "unrestricted"
} 0.

private:
CCTK_REAL Xt1_bound_scalar "Dirichlet boundary value" STEERABLE=ALWAYS
{
  *:* :: "unrestricted"
} 0.

private:
CCTK_REAL Xt2_bound_scalar "Dirichlet boundary value" STEERABLE=ALWAYS
{
  *:* :: "unrestricted"
} 0.

private:
CCTK_REAL Xt3_bound_scalar "Dirichlet boundary value" STEERABLE=ALWAYS
{
  *:* :: "unrestricted"
} 0.

private:
CCTK_REAL trK_bound_scalar "Dirichlet boundary value" STEERABLE=ALWAYS
{
  *:* :: "unrestricted"
} 0.

private:
CCTK_REAL At11_bound_scalar "Dirichlet boundary value" STEERABLE=ALWAYS
{
  *:* :: "unrestricted"
} 0.

private:
CCTK_REAL At12_bound_scalar "Dirichlet boundary value" STEERABLE=ALWAYS
{
  *:* :: "unrestricted"
} 0.

private:
CCTK_REAL At13_bound_scalar "Dirichlet boundary value" STEERABLE=ALWAYS
{
  *:* :: "unrestricted"
} 0.

private:
CCTK_REAL At22_bound_scalar "Dirichlet boundary value" STEERABLE=ALWAYS
{
  *:* :: "unrestricted"
} 0.

private:
CCTK_REAL At23_bound_scalar "Dirichlet boundary value" STEERABLE=ALWAYS
{
  *:* :: "unrestricted"
} 0.

private:
CCTK_REAL At33_bound_scalar "Dirichlet boundary value" STEERABLE=ALWAYS
{
  *:* :: "unrestricted"
} 0.

private:
CCTK_REAL alpha_bound_scalar "Dirichlet boundary value" STEERABLE=ALWAYS
{
  *:* :: "unrestricted"
} 0.

private:
CCTK_REAL dalpha1_bound_scalar "Dirichlet boundary value" STEERABLE=ALWAYS
{
  *:* :: "unrestricted"
} 0.

private:
CCTK_REAL dalpha2_bound_scalar "Dirichlet boundary value" STEERABLE=ALWAYS
{
  *:* :: "unrestricted"
} 0.

private:
CCTK_REAL dalpha3_bound_scalar "Dirichlet boundary value" STEERABLE=ALWAYS
{
  *:* :: "unrestricted"
} 0.

private:
CCTK_REAL beta1_bound_scalar "Dirichlet boundary value" STEERABLE=ALWAYS
{
  *:* :: "unrestricted"
} 0.

private:
CCTK_REAL beta2_bound_scalar "Dirichlet boundary value" STEERABLE=ALWAYS
{
  *:* :: "unrestricted"
} 0.

private:
CCTK_REAL beta3_bound_scalar "Dirichlet boundary value" STEERABLE=ALWAYS
{
  *:* :: "unrestricted"
} 0.

private:
CCTK_REAL dbeta11_bound_scalar "Dirichlet boundary value" STEERABLE=ALWAYS
{
  *:* :: "unrestricted"
} 0.

private:
CCTK_REAL dbeta12_bound_scalar "Dirichlet boundary value" STEERABLE=ALWAYS
{
  *:* :: "unrestricted"
} 0.

private:
CCTK_REAL dbeta13_bound_scalar "Dirichlet boundary value" STEERABLE=ALWAYS
{
  *:* :: "unrestricted"
} 0.

private:
CCTK_REAL dbeta21_bound_scalar "Dirichlet boundary value" STEERABLE=ALWAYS
{
  *:* :: "unrestricted"
} 0.

private:
CCTK_REAL dbeta22_bound_scalar "Dirichlet boundary value" STEERABLE=ALWAYS
{
  *:* :: "unrestricted"
} 0.

private:
CCTK_REAL dbeta23_bound_scalar "Dirichlet boundary value" STEERABLE=ALWAYS
{
  *:* :: "unrestricted"
} 0.

private:
CCTK_REAL dbeta31_bound_scalar "Dirichlet boundary value" STEERABLE=ALWAYS
{
  *:* :: "unrestricted"
} 0.

private:
CCTK_REAL dbeta32_bound_scalar "Dirichlet boundary value" STEERABLE=ALWAYS
{
  *:* :: "unrestricted"
} 0.

private:
CCTK_REAL dbeta33_bound_scalar "Dirichlet boundary value" STEERABLE=ALWAYS
{
  *:* :: "unrestricted"
} 0.

private:
CCTK_REAL B1_bound_scalar "Dirichlet boundary value" STEERABLE=ALWAYS
{
  *:* :: "unrestricted"
} 0.

private:
CCTK_REAL B2_bound_scalar "Dirichlet boundary value" STEERABLE=ALWAYS
{
  *:* :: "unrestricted"
} 0.

private:
CCTK_REAL B3_bound_scalar "Dirichlet boundary value" STEERABLE=ALWAYS
{
  *:* :: "unrestricted"
} 0.

private:
CCTK_REAL CL_log_confac_bound_scalar "Dirichlet boundary value" STEERABLE=ALWAYS
{
  *:* :: "unrestricted"
} 0.

private:
CCTK_REAL CL_dlog_confac_bound_scalar "Dirichlet boundary value" STEERABLE=ALWAYS
{
  *:* :: "unrestricted"
} 0.

private:
CCTK_REAL CL_metric_bound_scalar "Dirichlet boundary value" STEERABLE=ALWAYS
{
  *:* :: "unrestricted"
} 0.

private:
CCTK_REAL CL_dmetric_bound_scalar "Dirichlet boundary value" STEERABLE=ALWAYS
{
  *:* :: "unrestricted"
} 0.

private:
CCTK_REAL CL_Gamma_bound_scalar "Dirichlet boundary value" STEERABLE=ALWAYS
{
  *:* :: "unrestricted"
} 0.

private:
CCTK_REAL CL_trace_curv_bound_scalar "Dirichlet boundary value" STEERABLE=ALWAYS
{
  *:* :: "unrestricted"
} 0.

private:
CCTK_REAL CL_curv_bound_scalar "Dirichlet boundary value" STEERABLE=ALWAYS
{
  *:* :: "unrestricted"
} 0.

private:
CCTK_REAL CL_lapse_bound_scalar "Dirichlet boundary value" STEERABLE=ALWAYS
{
  *:* :: "unrestricted"
} 0.

private:
CCTK_REAL CL_dlapse_bound_scalar "Dirichlet boundary value" STEERABLE=ALWAYS
{
  *:* :: "unrestricted"
} 0.

private:
CCTK_REAL CL_shift_bound_scalar "Dirichlet boundary value" STEERABLE=ALWAYS
{
  *:* :: "unrestricted"
} 0.

private:
CCTK_REAL CL_dshift_bound_scalar "Dirichlet boundary value" STEERABLE=ALWAYS
{
  *:* :: "unrestricted"
} 0.

private:
CCTK_REAL CL_dtshift_bound_scalar "Dirichlet boundary value" STEERABLE=ALWAYS
{
  *:* :: "unrestricted"
} 0.

