
/* Copyright 2013 Peter Diener, Nils Dorband, Roland Haas, Ian Hinder,
Christian Ott, Denis Pollney, Thomas Radke, Christian Reisswig, Erik
Schnetter, Barry Wardell and Burkhard Zink

This file is part of Llama.

Llama is free software: you can redistribute it and/or modify it under
the terms of the GNU General Public License as published by the Free
Software Foundation, either version 2 of the License, or (at your
option) any later version.

Llama is distributed in the hope that it will be useful, but WITHOUT
ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
for more details.

You should have received a copy of the GNU General Public License
along with Llama.  If not, see <http://www.gnu.org/licenses/>. */

#ifndef _IO_ASCII_SPS_
#define _IO_ASCII_SPS_


#include "io.h"
#include <iostream>
#include <fstream>
#include <sstream>
#include <string>

namespace SPS {


using namespace std;

/**
   ASCII IO class.
                                                                          */
class io_ascii : public io_base
{
   public :
            io_ascii(const char* basename_, 
                     const io_mode_t io_mode_ = overwrite, 
                     const int n_active_procs_ = 1, 
                     const int proc_id_ = 0) 
               : file(1), io_base(basename_, ".asc", io_mode_, n_active_procs_, proc_id_) { _n_io_procs = 1; open(); }
            
            virtual ~io_ascii() { close(); }
   
            /// return a vector with all registered times 
            virtual vector<CCTK_REAL>  get_times() { return _times; };        
            /// return a vector with all registered iterations
            virtual vector<int> get_cycles() { return _cycles; };       
            /// return the total number of timesteps
            virtual int         get_ntimesteps() { return _cycles.size(); };   
            
            /// open the ASCII file for the first time and eventually ovewrite it. The File handle
            /// will always be closed after the first opening. This is because we want to re-open/close the
            /// file each time we have performed a read/write process so that if the program crashes during other
            /// than write processes, the ASCII-file will not get corrupted because it was not properly closed.
            virtual void open()
            {
               
               assert(_n_active_procs == 1);
               assert(_proc_id == 0);
               
               if (_io_mode == overwrite)
               {
                  file = vector<fstream*>(_n_active_procs, NULL);
                  //file.assign(_n_active_procs, NULL);
                  
                  // only write to to the file that belongs to the current process
                  file[_proc_id] = new fstream;
                  file[_proc_id]->open(filename(_proc_id).c_str(), fstream::out | fstream::trunc);
                  assert(file[_proc_id]->good());
                  
                  *file[_proc_id] << "# ASCII file generated by SphericalSliceIOASCII\n\n";
               }
               // ...but if we want to append, we have to make sure, we use the same number of files!
               // So first, we try to find out the number of files that have been written
               if (_io_mode == read_only || _io_mode == append)
               {
                  assert(_n_active_procs == 1);
                  get_global_attribs();
               }
               
               if (_io_mode == read_only)
               {
                  assert(_io_mode != read_only);
               }
               
               if (_io_mode == append)
               {
                  assert(_n_active_procs == _n_io_procs);
                  
                  file = vector<fstream*>(_n_active_procs, NULL);
                  //file.assign(_n_active_procs, NULL);
                  
                  // open files for appending
                  file[_proc_id] = new fstream;
                  file[_proc_id]->open(filename(_proc_id).c_str(), fstream::out | fstream::app);
                  assert(file[_proc_id]->good());
               }
               
               // afterwards close everything since we will read/write open the file each time we want to access it...
               for (int i=0; i < file.size(); i++)
               {
                  if (file[i]) delete file[i];
                  file[i] = NULL;
               }
            }
            
            virtual void close()
            {
               // delete all opened file handles
               for (int i=0; i < file.size(); i++)
               {
                  if (file[i]) delete file[i];
                  file[i] = NULL;
               }
            }
            
            /// read global IO-attribs that are independent of the hierarchy/field such as the number of
            /// timesteps, number of processes, etc.
            /// Here, we simply read the last timestep found in file. We will
            /// not know about other timesteps.
            virtual void get_global_attribs() 
            {
	       // commented out because Portland compiler complains
	       
               /*_n_io_procs = 1;
               
               _n_timesteps = 0;
               
               file[_proc_id] = new fstream;
               file[_proc_id]->open(filename(_proc_id).c_str(), fstream::in | fstream::ate);
               assert(file[_proc_id]->good());
               
               file[_proc_id]->unget();
               char c;
               bool found = false;
               while (!found && file[_proc_id]->tellg() > ios::beg)
               {
                  // browse to beginning of line
                  do
                  {
                     file[_proc_id]->unget();
                     c = file[_proc_id]->peek();
                  } while (c != '\n' && file[_proc_id]->tellg() > ios::beg);
                  if (file[_proc_id]->tellg() != ios::beg)
                     file[_proc_id]->get(c);
                  c = file[_proc_id]->peek();
                  if (c != '\n' && c != '#')
                     found = true;
                  else
                     file[_proc_id]->unget();
               }
               
               if (!found)
               {
                  cout << "------ no timesteps registered!" << endl;
                  return;
               }
               // now we should be at the beginning of a valid line
               char line[1000];
               file[_proc_id]->getline(line, 1000);
               
               // the first two columns make up cycle and time
               istringstream istr;
               istr.str(string(line));
               int mycycle;
               double mytime;
               istr >> mycycle;
               istr >> ws;
               istr >> mytime;
               
               _n_timesteps = 1;
               
               _cycles = vector<int>(1, mycycle);
               _times = vector<CCTK_REAL>(1, mytime);
               */
            }
            
            /// write global data-attributes into file. If they already exist, they will be overwritten.
            virtual void put_global_attribs() 
            {
               
            }
            
            /// set the file-handle to the 
            virtual void set_to_timestep(const int timestep_) { };
            
            /// returns the current timestep in the file handle
            virtual int get_timestep() const { return cur_timestep; }
            
            /// create a new timestep in the file and make it active.
            /// If this timestep already exists, then simply set it to it.
            virtual void create_new_timestep(const int cycle, const CCTK_REAL time) 
            {
               int ts = timestep_already_registered(cycle);
               if (ts >= 0)
               {
                  cur_timestep = ts;
                  cur_cycle = _cycles[ts];
                  cur_time = _times[ts];
               }
               else
               {
                  cur_timestep = _n_timesteps; 
                  _n_timesteps++; 
                  cur_cycle = cycle; 
                  cur_time = time; 
                  _cycles.push_back(cycle);
                  _times.push_back(time);
                  
                  new_timestep = true;
               }
            }
            
            /// write a CCTK_REAL-dataset to the file
            /// If this is the first write for this timestep,
            /// we store the rank and dimensions. All subsequent
            /// write-calls for this timestep then have to have the same rank
            /// and dimensions and are appended as additional columns. 
            virtual void write(const attributes& attribs,     // a list of attribs that are attached to the dataset
                               const char* name,              // name of the dataset
                               const int  rank,               // rank of the dataset
                               const vector<int> dims,        // extension in each dim
                               const double* buffer)          // the buffer that shall be written
            {
               // a copy of the attribs
               attributes a = attribs;
               
               // attach time and cycle attributes
               a << attribute<int>("timestep", cur_cycle);
               a << attribute<double>("time", cur_time);
               
               if (!buffer) return;
               
               // save rank and dimensions of buffer for the current timestep
               // These dimensions are then locked to the same values for the entire
               // timestep until we get a call to "create_new_timestep"
               if (new_timestep)
               {
                  assert(rank <= 3); // we will maximally handle 3d data. 
                  _rank = rank;
                  _dims = dims;
               }
               else
               {
                  assert(_rank == rank);
                  for (int i=0; i < rank; ++i)
                  {
                     assert(_dims[i] == dims[i]);
                  }
               }
               
               // open for data-appending
               file[_proc_id] = new fstream;
               file[_proc_id]->open(filename(_proc_id).c_str(), fstream::in | fstream::out | fstream::ate);
               assert(file[_proc_id]->good());
               
               // set formatting flags
               file[_proc_id]->precision(14);
               file[_proc_id]->setf(ios::scientific);
               file[_proc_id]->setf(ios::fixed);
               file[_proc_id]->setf(ios::showpoint);
               
               int buffer_size = 1;
               for (int i=0; i < rank; ++i)
                  buffer_size *= dims[i];
               
               deque<char*> lines(0);
               
               // insert some blank lines and save the file offset of this timestep
               if (new_timestep)
               {
                  *file[_proc_id] << "\n\n\n\n";
                  cur_timestep_offset = file[_proc_id]->tellp();
                  //cout << "-------------" << cur_timestep_offset << endl;
               }
               else
               {
                  //cout << "-------------" << cur_timestep_offset << endl;
                  file[_proc_id]->seekg(cur_timestep_offset);
                  file[_proc_id]->seekp(cur_timestep_offset);
                  
                  // we have to read in the entire file-buffer from this position up until the end
                  int l = 0;
                  while (file[_proc_id]->good())
                  {
                     lines.resize(l+1);
                     lines[l] = new char[1000];
                     file[_proc_id]->getline(lines[l], 1000);
                     l++;
                  }
                  file[_proc_id]->seekp(cur_timestep_offset);
                  file[_proc_id]->seekg(cur_timestep_offset);
               }
               
               int xcount = 0;
               int ycount = 0;
               int zcount = 0;
               int l = 0;
               for (int i=0; i < buffer_size; ++i)
               {
                  // if we have the first call for this timestep, we can simply dump the data as the first column
                  if (new_timestep)
                  {
                     *file[_proc_id] << /*buffer[i] <<*/ "0 \n";
                  }
                  else
                  {
//                      file[_proc_id]->ignore(1000, '\n');
//                      file[_proc_id]->unget();
//                      file[_proc_id]->seekg(/*cur_timestep_offset);/*/file[_proc_id]->tellg());
//                      *file[_proc_id]/*write("1 ", 2);/*/ << "1 ";//buffer[i];
//                      file[_proc_id]->seekg(file[_proc_id]->tellp());
                        
                     *file[_proc_id]/*write("1 ", 2);/*/ /*<< lines[l]*/ << "1 \n";//buffer[i];
                  }
               
                  xcount++;
                  l++;
                  
                  if (rank > 1)
                     if (xcount == dims[0])
                     {
                        xcount = 0;
                        ycount++;
                        *file[_proc_id] << "\n";
                        l++;
                     }
                  if (rank > 2)
                     if (ycount == dims[1])
                     {
                        ycount = 0;
                        *file[_proc_id] << "\n";
                        l++;
                     }
               }
               
               for (int i=0; i < lines.size(); ++i)
                  delete [] lines[i];
               
               // close again
               delete file[_proc_id];
               file[_proc_id] = NULL;
               
               new_timestep = false;
            }
            
            
            /// write a vector<CCTK_REAL>-dataset to the file
            /// in this case, this is done by creating an individual dataset for each component
            virtual void write(const attributes& attribs,     // a list of attribs that are attached to the dataset
                               const char* name,              // name of the dataset
                               const int  rank,
                               const vector<int> dims,
                               const vector<double>* buffer)     // the buffer that shall be written
            {
               if (!buffer) return;
               
               for (int d=0; d < buffer[0].size(); d++)
               {
                  attributes a = attribs;
                  a << attribute<int>("vector-component", d);
                  ostringstream out;
                  out << name << "::d=" << d;
                  
                  // create new double-buffer
                  int size = 1;
                  for (int i=0; i < rank; i++)
                     size *= dims[i];
                  
                  double* buf = new double[size];
                  
                  // copy vector component to new CCTK_REAL-buffer
                  for (int c=0; c < size; c++)
                     buf[c] = buffer[c][d];
                  
                  // write CCTK_REAL-buffer
                  write(a, out.str().c_str(), rank, dims, buf);
                  delete [] buf;
               }
            }
            
            virtual void read(attributes& attribs,     // a list of CCTK_REAL-attribs that are attached to the dataset
                              const char* name,                                 // name of the dataset
                              CCTK_REAL* buffer)                                  // the buffer where data will be stored
            {
               
            }
            
   private :
            /// all file handles for each processor
            vector<fstream*> file;
            
            /// rank and dimensions of current time-step
            int _rank;
            vector<int> _dims;
            bool new_timestep;
            /// the offset in file of the current timestep
            streampos cur_timestep_offset;
};








} // namespace






#endif


