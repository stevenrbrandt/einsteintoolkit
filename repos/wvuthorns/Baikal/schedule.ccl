
# This schedule.ccl file was automatically generated by NRPy+.
#   You are advised against modifying it directly; instead
#   modify the Python code that generates it.

# First allocate storage for one timelevel of ADMBase gridfunctions, which is the
#    bare minimum needed by NRPy+. If another thorn (e.g., ADMBase itself) requests
#    more timelevels of storage, Cactus automatically allocates the maximum requested.
STORAGE: ADMBase::metric[1], ADMBase::curv[1], ADMBase::lapse[1], ADMBase::shift[1]

# Next allocate storage for all 3 gridfunction groups used in Baikal
STORAGE: evol_variables[3]     # Evolution variables
STORAGE: evol_variables_rhs[1] # Variables storing right-hand-sides
STORAGE: aux_variables[3]      # Diagnostics variables
STORAGE: auxevol_variables[1]  # Single-timelevel storage of variables needed for evolutions.

# The following scheduler is based on Lean/LeanBSSNMoL/schedule.ccl

schedule Baikal_Banner at STARTUP
{
  LANG: C
  OPTIONS: meta
} "Output ASCII art banner"

schedule Baikal_RegisterSlicing at STARTUP after Baikal_Banner
{
  LANG: C
  OPTIONS: meta
} "Register 3+1 slicing condition"

schedule Baikal_Symmetry_registration at BASEGRID
{
  LANG: C
  OPTIONS: Global
} "Register symmetries, the CartGrid3D way."

schedule Baikal_zero_rhss at BASEGRID after Baikal_Symmetry_registration
{
  LANG: C
} "Idea from Lean: set all rhs functions to zero to prevent spurious nans"

schedule Baikal_ADM_to_BSSN at CCTK_INITIAL after ADMBase_PostInitial
{
  LANG: C
  OPTIONS: Local
  SYNC: evol_variables
} "Convert initial data into BSSN variables"

schedule GROUP ApplyBCs as Baikal_ApplyBCs at CCTK_INITIAL after Baikal_ADM_to_BSSN
{
} "Apply boundary conditions"


# MoL: registration

schedule Baikal_MoL_registration in MoL_Register
{
  LANG: C
  OPTIONS: META
} "Register variables for MoL"


# MoL: compute RHSs, etc

schedule Baikal_driver_BSSN_T4UU in MoL_CalcRHS as Baikal_T4UU before Baikal_BSSN_to_ADM
{
  LANG: C
} "MoL: Compute T4UU, needed for BSSN RHSs."

schedule Baikal_driver_pt1_BSSN_Ricci in MoL_CalcRHS as Baikal_Ricci before Baikal_RHS
{
  LANG: C
} "MoL: Compute Ricci tensor"

schedule Baikal_driver_pt2_BSSN_RHSs in MoL_CalcRHS as Baikal_RHS after Baikal_Ricci
{
  LANG: C
} "MoL: Evaluate BSSN RHSs"

schedule Baikal_NewRad in MoL_CalcRHS after Baikal_RHS
{
  LANG: C
} "NewRad boundary conditions, scheduled right after RHS eval."

schedule Baikal_floor_the_lapse in MoL_PostStep before Baikal_enforce_detgammabar_constraint before BC_Update
{
  LANG: C
} "Set lapse = max(lapse_floor, lapse)"

schedule Baikal_enforce_detgammabar_constraint in MoL_PostStep before BC_Update
{
  LANG: C
} "Enforce detgammabar = detgammahat (= 1 in Cartesian)"

schedule Baikal_BoundaryConditions_evolved_gfs in MoL_PostStep
{
  LANG: C
  OPTIONS: LEVEL
  SYNC: evol_variables
} "Apply boundary conditions and perform AMR+interprocessor synchronization"

schedule GROUP ApplyBCs as Baikal_ApplyBCs in MoL_PostStep after Baikal_BoundaryConditions_evolved_gfs
{
} "Group for applying boundary conditions"


# Next update ADM quantities

schedule Baikal_BSSN_to_ADM in MoL_PostStep after Baikal_ApplyBCs before ADMBase_SetADMVars
{
  LANG: C
  OPTIONS: Local
} "Perform BSSN-to-ADM conversion. Useful for diagnostics."

# Compute Hamiltonian & momentum constraints

schedule Baikal_driver_BSSN_T4UU in MoL_PseudoEvolution before Baikal_BSSN_constraints
{
  LANG: C
  OPTIONS: Local
} "MoL_PseudoEvolution: Compute T4UU, needed for BSSN constraints"


schedule Baikal_BSSN_constraints in MoL_PseudoEvolution
{
  LANG: C
  OPTIONS: Local
} "Compute BSSN (Hamiltonian and momentum) constraints"

schedule Baikal_BoundaryConditions_aux_gfs in MoL_PseudoEvolution after Baikal_BSSN_constraints
{
  LANG: C
  OPTIONS: LEVEL
  SYNC: aux_variables
} "Enforce symmetry BCs in constraint computation"


schedule Baikal_BSSN_to_ADM in MoL_PseudoEvolution after Baikal_BoundaryConditions_aux_gfs
{
  LANG: C
  OPTIONS: Local
} "Perform BSSN-to-ADM conversion in MoL_PseudoEvolution. Needed for proper HydroBase integration."

schedule GROUP ApplyBCs as Baikal_auxgfs_ApplyBCs in MoL_PseudoEvolution after Baikal_BoundaryConditions_aux_gfs
{
} "Apply boundary conditions"
