
# This schedule.ccl file was automatically generated by NRPy+.
#   You are advised against modifying it directly; instead
#   modify the Python code that generates it.

# First allocate storage for one timelevel of ADMBase gridfunctions, which is the
#    bare minimum needed by NRPy+. If another thorn (e.g., ADMBase itself) requests
#    more timelevels of storage, Cactus automatically allocates the maximum requested.
STORAGE: ADMBase::metric[1], ADMBase::curv[1], ADMBase::lapse[1], ADMBase::shift[1]

# Next allocate storage for all 3 gridfunction groups used in BaikalVacuum
STORAGE: evol_variables[3]     # Evolution variables
STORAGE: evol_variables_rhs[1] # Variables storing right-hand-sides
STORAGE: aux_variables[3]      # Diagnostics variables
STORAGE: auxevol_variables[1]  # Single-timelevel storage of variables needed for evolutions.

# The following scheduler is based on Lean/LeanBSSNMoL/schedule.ccl

schedule BaikalVacuum_Banner at STARTUP
{
  LANG: C
  OPTIONS: meta
} "Output ASCII art banner"

schedule BaikalVacuum_RegisterSlicing at STARTUP after BaikalVacuum_Banner
{
  LANG: C
  OPTIONS: meta
} "Register 3+1 slicing condition"

schedule BaikalVacuum_Symmetry_registration at BASEGRID
{
  LANG: C
  OPTIONS: Global
} "Register symmetries, the CartGrid3D way."

schedule BaikalVacuum_zero_rhss at BASEGRID after BaikalVacuum_Symmetry_registration
{
  LANG: C
} "Idea from Lean: set all rhs functions to zero to prevent spurious nans"

schedule BaikalVacuum_ADM_to_BSSN at CCTK_INITIAL after ADMBase_PostInitial
{
  LANG: C
  OPTIONS: Local
  SYNC: evol_variables
} "Convert initial data into BSSN variables"

schedule GROUP ApplyBCs as BaikalVacuum_ApplyBCs at CCTK_INITIAL after BaikalVacuum_ADM_to_BSSN
{
} "Apply boundary conditions"


# MoL: registration

schedule BaikalVacuum_MoL_registration in MoL_Register
{
  LANG: C
  OPTIONS: META
} "Register variables for MoL"


# MoL: compute RHSs, etc

schedule BaikalVacuum_driver_pt1_BSSN_Ricci in MoL_CalcRHS as BaikalVacuum_Ricci before BaikalVacuum_RHS
{
  LANG: C
} "MoL: Compute Ricci tensor"

schedule BaikalVacuum_driver_pt2_BSSN_RHSs in MoL_CalcRHS as BaikalVacuum_RHS after BaikalVacuum_Ricci
{
  LANG: C
} "MoL: Evaluate BSSN RHSs"

schedule BaikalVacuum_NewRad in MoL_CalcRHS after BaikalVacuum_RHS
{
  LANG: C
} "NewRad boundary conditions, scheduled right after RHS eval."

schedule BaikalVacuum_floor_the_lapse in MoL_PostStep before BaikalVacuum_enforce_detgammabar_constraint before BC_Update
{
  LANG: C
} "Set lapse = max(lapse_floor, lapse)"

schedule BaikalVacuum_enforce_detgammabar_constraint in MoL_PostStep before BC_Update
{
  LANG: C
} "Enforce detgammabar = detgammahat (= 1 in Cartesian)"

schedule BaikalVacuum_BoundaryConditions_evolved_gfs in MoL_PostStep
{
  LANG: C
  OPTIONS: LEVEL
  SYNC: evol_variables
} "Apply boundary conditions and perform AMR+interprocessor synchronization"

schedule GROUP ApplyBCs as BaikalVacuum_ApplyBCs in MoL_PostStep after BaikalVacuum_BoundaryConditions_evolved_gfs
{
} "Group for applying boundary conditions"


# Next update ADM quantities

schedule BaikalVacuum_BSSN_to_ADM in MoL_PostStep after BaikalVacuum_ApplyBCs before ADMBase_SetADMVars
{
  LANG: C
  OPTIONS: Local
} "Perform BSSN-to-ADM conversion. Useful for diagnostics."

# Compute Hamiltonian & momentum constraints


schedule BaikalVacuum_BSSN_constraints in MoL_PseudoEvolution
{
  LANG: C
  OPTIONS: Local
} "Compute BSSN (Hamiltonian and momentum) constraints"

schedule BaikalVacuum_BoundaryConditions_aux_gfs in MoL_PseudoEvolution after BaikalVacuum_BSSN_constraints
{
  LANG: C
  OPTIONS: LEVEL
  SYNC: aux_variables
} "Enforce symmetry BCs in constraint computation"


schedule GROUP ApplyBCs as BaikalVacuum_auxgfs_ApplyBCs in MoL_PseudoEvolution after BaikalVacuum_BoundaryConditions_aux_gfs
{
} "Apply boundary conditions"
